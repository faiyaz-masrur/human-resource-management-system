# Use a Docker image that has the 'docker' CLI installed
image: docker:latest

# Enable Docker-in-Docker service to allow running 'docker' commands
services:
  - docker:dind

variables:
  # Base image name for backend, tagged with the commit SHA
  CI_REGISTRY_IMAGE_BACKEND: $CI_REGISTRY_IMAGE/backend:$CI_COMMIT_SHA
  # Base image name for frontend, tagged with the commit SHA
  CI_REGISTRY_IMAGE_FRONTEND: $CI_REGISTRY_IMAGE/frontend:$CI_COMMIT_SHA
  # Latest tags for easy deployment reference
  CI_REGISTRY_IMAGE_BACKEND_LATEST: $CI_REGISTRY_IMAGE/backend:latest
  CI_REGISTRY_IMAGE_FRONTEND_LATEST: $CI_REGISTRY_IMAGE/frontend:latest

stages:
  - build
  - deploy

before_script:
  # Log in to the GitLab Container Registry
  - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY

# --- Build Jobs ---
build_backend:
  stage: build
  script:
    # 1. Build the backend image using its Dockerfile in the './backend' context
    - docker build -t $CI_REGISTRY_IMAGE_BACKEND ./backend
    # 2. Also tag it as 'latest' (optional, but useful for quick reference)
    - docker tag $CI_REGISTRY_IMAGE_BACKEND $CI_REGISTRY_IMAGE_BACKEND_LATEST
    # 3. Push both tags to the registry
    - docker push $CI_REGISTRY_IMAGE_BACKEND
    - docker push $CI_REGISTRY_IMAGE_BACKEND_LATEST
  # Only run if files in the backend directory change (optimization)
  rules:
    - changes:
      - backend/**/*
      - docker-compose.yml
    # Run by default if no changes rule matches
    - when: always

build_frontend:
  stage: build
  script:
    # 1. Build the frontend image using its Dockerfile in the './frontend' context
    - docker build -t $CI_REGISTRY_IMAGE_FRONTEND ./frontend
    # 2. Also tag it as 'latest'
    - docker tag $CI_REGISTRY_IMAGE_FRONTEND $CI_REGISTRY_IMAGE_FRONTEND_LATEST
    # 3. Push both tags to the registry
    - docker push $CI_REGISTRY_IMAGE_FRONTEND
    - docker push $CI_REGISTRY_IMAGE_FRONTEND_LATEST
  rules:
    - changes:
      - frontend/**/*
      - docker-compose.yml
    - when: always

# --- Deploy Job ---
deploy_production:
  stage: deploy
  image: alpine/git:latest # Use a lightweight image with SSH capabilities
  before_script:
    # Prepare SSH key from variable for deployment
    - chmod 600 $ID_RSA
    - eval $(ssh-agent -s)
    - ssh-add $ID_RSA
  script:
    - ssh -o StrictHostKeyChecking=no $DEPLOY_USER@$DEPLOY_SERVER_IP "
      # 1. Log in to the registry on the deployment server
      docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY &&
      # 2. Export environment variables for the deployment script
      export BACKEND_IMAGE=$CI_REGISTRY_IMAGE_BACKEND_LATEST &&
      export FRONTEND_IMAGE=$CI_REGISTRY_IMAGE_FRONTEND_LATEST &&
      export CI_REGISTRY=$CI_REGISTRY &&
      # 3. Navigate to the project directory and run the deployment script
      cd /path/to/your/project &&
      sh deploy_script.sh
      "
  environment:
    name: production
  when: manual # Only deploy manually to production
  needs:
    - build_backend
    - build_frontend